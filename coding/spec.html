<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Policy Lab</title>
 <style>
    p.small {
      line-height: 0.8;
    }

</style>
</head>
<body>
  <div align="right">
    Author: Trevor Hackett
  </div>
  <div align="center">
    <h2>DataStore Lab</h2>
  </div>

<h3>Topics Covered</h3>
<p>
  - Policy-based Class Design<br>
  - Advanced Templates / Template Metaprograaming<br>
  - Multiple Inheritance<br>
</p>

<h3>Overview</h3>
<p>
  All of the programs you've written up to this point have
  been designed to solve some very specific problem. The
  specification details exactly what the program should do
  given all possible inputs. All you have had to do is come
  up with the best way to implement that functionality without
  error (or at least handling errors gracefully). This works
  well for learning about concepts and how to write programs
  revolving around some computer science concept. What it doesn't do
  is provide the kind of flexibility that allows other programmers
  to take code you've written and extend it for their own purposes. In developing
  an application that is going to be used by any number of
  developers for whatever purpose they bring to the table, we
  want to provide a framework that will bend and stretch to their
  needs. Oftentimes, they will write their own classes that
  they want to fit into the framework we've provided.
</p>

<p>
  A broad
  category of programs that fit this description is an API.
  An API (application programming interface) is a specification
  of some set of functions, data structures, classes, etc that
  provide some functionality. Hopefully from an operating systems
  course, you're familiar with the POSIX API which provides an
  interface in the form of <em>system calls</em> for applications
  that we write to utilize functionality
  the operating system manages.
</p>

<p>
  APIs such as POSIX strive to accomplish the very important task
  of allowing us to use code and functionality that we didn't write,
  but they serve another very useful promise. They separate the 
  functionality of code from its usage. Anyone could re-write the POSIX
  functions - as long as they take the same
  input, give the same output, and have the same side effects, then the
  libraries would be viewed as interchangeable. With this well defined
  interface, operating system developers can make changes to the underlying
  OS as long as they obey what the POSIX API promises. At the same time,
  application developers can make changes to their applications using
  the POSIX methods without worrying that the system calls will change
  or worse that their code will change the behavior of system calls.
</p>


<h3>Your first task</h3>
<p>
  The first goal for this lab is to design a very simple API
  resembling some kind of data storage unit. We'll call the class
  DataStore, because it's
  very general. All DataStore can do is be read from and written to
  by any application/computer/whatever. DataStore doesn't even understand
  different types - it can only read/write <code>char</code>s (from/into
  <code>string</code>s, by extension). You are to write a class that
  provides the following public functionality:
</p>

<pre>
class DataStore {
public:
    // p is the persistence of data - when data is written
    // to DataStore, it stays there for p seconds, after which
    // read will not include that expired data
  DataStore(int p);

    // s is a character array (string). DataStore records each
    // character in s and retains it for as many seconds as is
    // passed into the constructor
  void write(string s);

    // s is a reference to some character array (string). DataStore
    // fills that character array with all data (chars) that
    // it currently has. If there are n chars in the DataStore,
    // then when this function ends, s[0] through s[n-1] contains
    // those characters and s.size() == n
  void read(string& s);
};
</pre>

<p>
  You can, of course, add any private member variables and functions
  that you see fit. If you need to add a destructor you may,
  although I'd recomment utilizing STL containers to provide
  any functionality you'd like to get from dynamic memory.
</p>

<p>
  The <strong>persistence</strong> of data is worth clarifying.
  When data is written
  to DataStore, the DataStore doesn't keep track of it forever.
  There are many reasons to
  provide evict data from a DataStore. Maybe the DataStore models a
  cache and so when it fills up, the cache has to make space. Maybe it
  models a bus that only holds data instantaneously and only listeners
  that read constantly receive that data. To keep our model very general
  , we'll say data persists some number of seconds before being cleaned up.
  Your constructor should take in one integer parameter specifying exactly
  how many seconds data written to the DataStore lasts.

  This program is still designed to be entirely single threaded - 
  we'll get to multi-threaded programs in a future lab. Because of
  this, the DataStore cannot continuously monitor data it holds
  to remove expired data as soon as it expires. Instead, your
  DataStore class must ensure that when a read happens, no expired
  data is read.
</p>

<p>
  A user of this class
  can make a couple of assumptions that you must guarentee:<br>

  <ol>
    1) <strong>DataStore is limitless</strong>, as in
    someone who knows about the DataStore can write infinite characters to
    it without error (if they fill your entire virtual address space,
    we'll let the underlying OS take care of things)<br>

    2) <strong>DataStore has no privacy</strong>, as in when
    someone wants some data,
    they get all of the data in DataStore, not just the data at some
    address - they not only can assume this, but they must deal with
    this slight inconvenience (more on that later)<br>

    3) <strong>DataStore's data cannot be altered</strong> - only added to.
    All an application aware of the DataStore can do
    is write (store more data) or read (get all data in DataStore), I
    cannot modify the data in the DataStore<br>
  </ol>
</p>

<h3>Your second task</h3>

<p>
  Now that we have a simple way of storing data in a general sense,
  let's write some applications that share such data. 
</p>