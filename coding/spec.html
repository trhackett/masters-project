<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Policy Lab</title>
 <style>
    p.small {
      line-height: 0.8;
    }

</style>
</head>
<body>
  <div align="right">
    Author: Trevor Hackett
  </div>
  <div align="center">
    <h2>DataStore Lab</h2>
  </div>

<h3>Topics Covered</h3>
<p>
  - Policy-based Class Design<br>
  - Advanced Templates / Template Metaprograaming<br>
  - Multiple Inheritance<br>
</p>

<h3>Overview</h3>
<p>
  All of the programs you've written up to this point have
  been designed to solve some very specific problem. The
  specification details exactly what the program should do
  given all possible inputs. All you have had to do is come
  up with the best way to implement that functionality without
  error (or at least handling errors gracefully). This works
  well for learning about concepts and how to write programs
  revolving around some computer science concept. What it doesn't do
  is provide the kind of flexibility that allows other programmers
  to take code you've written and extend it for their own purposes. In developing
  an application that is going to be used by any number of
  developers for whatever purpose they bring to the table, we
  want to provide a framework that will bend and stretch to their
  needs. Oftentimes, they will write their own classes that
  they want to fit into the framework we've provided.
</p>

<p>
  A broad
  category of programs that fit this description is an API.
  An API (application programming interface) is a specification
  of some set of functions, data structures, classes, etc that
  provide some functionality. Hopefully from an operating systems
  course, you're familiar with the POSIX API which provides an
  interface in the form of <em>system calls</em> for applications
  that we write to utilize functionality
  the operating system manages.
</p>

<p>
  APIs such as POSIX strive to accomplish the very important task
  of allowing us to use code and functionality that we didn't write,
  but they serve another very useful service. They separate the 
  functionality of code from its usage. Anyone could re-write the POSIX
  functions and tell me how to use them - as long as they take the same
  output, give the same output, and have the same side effects, these
  libraries would be viewed as interchangeable. With a well defined
  interface, operating system developers can make changes to the underlying
  OS as long as they obey what the POSIX API promises and at the same time
  application developers can make changes to their applications using
  the POSIX methods without worrying that the system calls will change
  or worse that they'll change the behavior of the system calls.
</p>


<h3>Your first task</h3>
<p>
  Your first goal for this lab is to design a very simple API that
  resembles a DataStore unit. We'll call the class DataStore, because it's
  very general. All DataStore can do is be read from and written to
  by any application/computer/whatever. DataStore doesn't even understand
  different types - it can only read/write <code>char</code>s (and,
  by extension, <code>string</code>s). You are to write a class that
  provides the following public functionality:
</p>

<pre>
class DataStore {
public:
    // p is the persistance of data - when data is written
    // to DataStore, it stays there for p seconds, after which
    // read will not include that expired data
  DataStore(int p);

    // s is a character array (string). DataStore records each
    // character in s and retains it for as many seconds as is
    // passed into the constructor
  void write(string s);

    // s is a reference to some character array (string). DataStore
    // fills that character array with all data (chars) that
    // it currently has. 
  void read(string& s);
};
</pre>

<p>
  The persistance of data is worth clarifying. When data is written
  to DataStore, the DataStore can't keep track of it forever. You constructor
  should take in one integer parameter specifying exactly how many
  seconds data written to the DataStore lasts.
</p>

<p>
  You, of course, can add any private functionality that you prefer
  as long as your DataStore class obeys this interface. A user of this class
  can make a couple of assumptions that you must guarentee:<br>

  1) DataStore is limitless, as in
  someone who knows about the DataStore can write infinite characters to
  it without error (if they fill your entire virtual address space,
  we'll let the underlying OS take care of things)<br>

  2) DataStore has no protection, as in when someone wants some data,
  they get all of the data in DataStore, not just the data at some
  address - they not only can assume this, but they must deal with
  this slight inconvenience (more on that later)<br>
</p>
